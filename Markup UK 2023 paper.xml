<?xml version="1.0" encoding="UTF-8"?>
<?xml-model href="http://docbook.org/xml/5.1/rng/docbook.rng" schematypens="http://relaxng.org/ns/structure/1.0"?>
<?xml-model href="http://docbook.org/xml/5.1/sch/docbook.sch" type="application/xml" schematypens="http://purl.oclc.org/dsdl/schematron"?>
<!--
    WHO - me
    WHAT - new impl in XQuery, details around BaseX, compiled schemas, any caveats/limitations, interoperability
    WHERE - GitHub
    WHEN - now, but not production-ready - early release
    HOW - BaseX + unit testing and eval/compile approaches; details on impl and gremlins encountered
    WHY - ???
    -->
<!DOCTYPE article [
<!ENTITY endash "&#x2013;">
]>
<article xmlns="http://docbook.org/ns/docbook"
    xmlns:xlink="http://www.w3.org/1999/xlink" version="5.1">
    <info>
        <title>XQS: A Native XQuery Schematron Implementation</title>
        <author>
            <personname><firstname>Andrew</firstname><surname>Sales</surname></personname>
        </author>
        <abstract><para>This paper will cover XQuery for Schematron (XQS) (pron. /ɛksˈkjuz/),<footnote><para><link xlink:href="https://github.com/AndrewSales/XQS">https://github.com/AndrewSales/XQS</link></para></footnote> a Schematron processor being implemented in native &endash; and naïve &endash; XQuery. To the author's knowledge, there are no complete implementations publicly available at this time.<footnote><para>Though note the experimental work in this area by David Maus: <link xlink:href="https://github.com/dmj/schematron-xquery">https://github.com/dmj/schematron-xquery</link>.</para></footnote> The purpose of the work is at least two-fold: to demonstrate the utility of an XQuery query language binding for arguably the primary quality assurance technology applicable to XML, and to provide a second "reference" implementation while work on the latest revision of the ISO standard proceeds. Although not required by the standardization process, it clearly helps to be able to answer the question standards authors should consider when new features present themselves: How would you implement that?</para></abstract>
    </info>
    <section>
        <title>Background</title>
        <para>The existence of a Schematron validator implemented in XQuery has been the subject of periodic enquiry in the community.<footnote><para>See e.g. <link xlink:href="http://x-query.com/pipermail/talk/2011-November/003704.html">http://x-query.com/pipermail/talk/2011-November/003704.html</link></para></footnote> Respondents on mailing lists typically indicate the existing and highly serviceable XQuery wrappers around an XSLT implementation, such as are available for the main XML databases.<biblioref linkend="schematron-existdb"/><biblioref linkend="schematron-basex"/><biblioref linkend="schematron-ML"/></para>
        <para>While Schematron has been implemented in a range of other languages,[CITE] apparently the only members of the XML technology stack to fulfil this role so far have been XPath, such as ph-schematron<biblioref linkend="ph-schematron"/> (in its "pure" variant) and the author's defunct XMLProbe, later open-sourced as Probatron.<biblioref linkend="probatron"/><footnote><para>The later updates archived at <link xlink:href="https://code.google.com/archive/p/probatron4j/">https://code.google.com/archive/p/probatron4j/</link> and <link xlink:href="https://code.google.com/archive/p/probatrondotnet/">https://code.google.com/archive/p/probatrondotnet/</link> are wrappers around the skeleton implementation.</para></footnote> and XSLT.<biblioref linkend="skeleton"/><biblioref linkend="schxslt"/> Indeed, to many Schematron users, the XSLT implementations <emphasis>are</emphasis> Schematron to all intents and purposes. It is a mark of the success of those implementations that they have come to be regarded in this way.</para>
        <para>There may however be advantages to pursuing a native XQuery implementation. The standard itself still defines a range of query language bindings (QLBs)<biblioref linkend="iso-qlbs"/>, some of which are moribund or of questionable longer-term value<footnote><para>E.g. STX and EXSLT, as raised in <link xlink:href="https://github.com/Schematron/schematron-enhancement-proposals/issues/26">https://github.com/Schematron/schematron-enhancement-proposals/issues/26</link>.</para></footnote>. There are QLBs for XPath and XSLT in all their current versions defined normatively, and while the values <literal>xquery</literal>, <literal>xquery3</literal> and <literal>xquery31</literal> are all reserved for future use, these are not defined normatively.</para>
        <para>For the purposes of updating the standard,<footnote><para>ISO/IEC JTC 1/SC 34 approved a new revision of the standard and convened a new working group to carry this out in September 2022.</para></footnote> the present work has obvious benefits in informing what a QLB for XQuery should look like. For the end user, it also gives them options not previously available, most obviously the native integration of a Schematron schema into an XQuery-based validation workflow, e.g. in a native XML database, or, as is the case with ph-schematron<biblioref linkend="ph-schematron"/>, the programmatic assembly of schemas. Further potential benefits to the XQuery user will be discussed in more detail below.</para>
        <para>This paper will examine three main areas arising from the work:</para>
        <itemizedlist>
            <listitem>
                <para>design choices made</para>
            </listitem>
            <listitem>
                <para>[...]</para>
            </listitem>
            <listitem>
                <para>how these may influence the next edition of ISO Schematron.</para>
            </listitem>
        </itemizedlist>
        <para>The lessons learned in these attempts will be expanded on below, and remaining work identified.</para>
    </section>
    <section>
        <title>Rationale</title>
        <para>Unlike some other bodies, <link xlink:href="https://www.iso.org/home.html">ISO</link> does not require any "reference" implementation to be developed in support of a standard it publishes. The so-called skeleton implementation was mothballed as no longer maintained in late 2020, and the main XSLT implementation at present is <link xlink:href="https://github.com/schxslt/schxslt">SchXslt</link>. Once ISO approved the work for a new edition of the standard, it seemed useful to have another implementation, in a query language not as yet defined by the standard, to support and inform this work. The author has also been a keen advocate of further Schematron implementations at previous community meetups<biblioref linkend="meetups"/>, and a further implementation of course introduces more choice and options for the schema author and end user alike.</para></section>
    <section>
        <title>Design goals</title>
        <para>The high-level brief was to produce an implementation conforming to ISO/IEC 19757-3:2020, written in XQuery alone. Conformance is defined in Clause 7 of the standard. What it terms <emphasis>Simple conformance</emphasis> amounts to reporting whether an XML document is valid to a given Schematron schema: a simple pass/fail, with SVRL<footnote><para>Schematron Validation Reporting Language, defined in Annex D (informative).</para></footnote> output not required. <emphasis>Full conformance</emphasis> is also defined, but does not expand much on that, adding as criteria correct attribute values and a proscription on duplicate variable names; SVRL is not mandated here either.<footnote><para>Technically, it could not be, since its definition in the standard is not normative.</para></footnote> To meet perhaps most users' expectations, align with SchXslt, as well as provide the means to compare outputs with that tool's, SVRL was deemed a necessity from the start; text output is also out of scope.</para>
        <para>An additional reason for choosing XQuery was the appeal of relatively rapid development facilitated by its concise and declarative syntax.</para>
        <section xml:id="conformanceOverPerformance">
            <title>Conformance over performance</title>
            <para>primarily in support of development of standard - not intended to be production-grade</para>
        </section>
        <section>
            <title>Dynamic evaluation</title>
            <para>The prospect of invoking validation directly - without any so-called schema "compilation" step - was also attractive, based on the author's previous work on XMLProbe and Probatron, which were coded in Java and used an XPath engine[CITE Jaxen] to evaluate patterns expressed in the schema without any intermediate steps. Admittedly, when using a setup such as the validation scenarios configurable in an IDE like oXygen[FOOTNOTE], the user is unaware of the three-step process of resolving includes, instantiating abstract rules and patterns, and producing a compiled schema in the form of an XSLT transform, but it would be an interesting exercise nonetheless.</para>
        </section>
        <section>
            <title>Portability</title>
            <para>Likewise the possibility of writing this tool in such a way that validation could be run directly, or using the schema compiled as XQuery, in an engine-agnostic way, i.e. that the code should be portable as far as possible.</para>
        </section>
    </section>
    <section>
        <title>Caveats</title>
        <para>This section sets out [...]</para>
        <section>
            <title>Expansion and inclusion</title>
            <para>The dynamic evaluation portion of the code was written first, to establish proof of concept. The next step was intended to be resolution of includes and expansion of abstract constructs, before turning to schema compilation. The view was taken that the greater challenge, and arguably more interesting feature of the work, lay in compiling to XQuery, so expansion and inclusion have been deferred for now[FOOTNOTE citing github issue]. In the meantime, users should rely on other tools (such as SchXslt) to perform these pre-processing steps if needed.</para>
        </section>
        <section>
            <title>"Native"?</title>
            <para>For reasons of familiarity in the main, BaseX[CITE] was chosen as the development platform, so the code uses its dialect of XQuery. This means that dynamic validation relies on that, but a generated XQuery ("compiled schema") uses no engine-specific functions, so also runs under e.g. Saxon[FOOTNOTE ABOUT differing opinions on escaping of braces]. The plan is to develop the dynamic part so that it can be run under other engines as well.</para>
        </section>
        <section>
            <title>"Naïve"?</title>
            <para>This should be taken to mean, in allusion to <xref linkend="conformanceOverPerformance"/> above, that the focus has been on producing a working implementation first and foremost, with little or no attention given at this stage to making it performant.</para>
        </section>
        <section>
            <title>Context is everything</title>
            <para>the context item for validation against a schema: a single document - refer to standard here ("instance document")</para>
            <para>also rule/@context: in contrast to the rule-based processing of XSLT (where rule/@context translates to xsl:template/@match), in XQuery we are pulling nodes we are interested in rather than them being pushed to us. So the decision here was to interpret rule/@context as being evaluated in the context of the instance document root. The obvious but important implication for schema authors targetting XSLT implementations is that e.g. <tag class="element">&lt;:rule context="*"></tag> will only match the root element, as opposed to any element in the document.</para>
            <para>the other QLBs specify what is allowed in a rule/@context - in line with the XPath and XSLT bindings, expecting this to be any expression returning a (sequence of) <emphasis>nodes</emphasis>[CHECKME: what XQuery production(s) would this be?].</para>
        </section>
    </section>
    <section>
        <title>Evaluated schema</title>
        <para>details of impl, any notable points:</para>
        <para>- use of map to establish and maintain validation context (namespaces, variables, functions)</para>
        <para>analogous to interpreted language (such as Python), where syntax errors can lurk in a branch of code that is not reached, for example rules or assertions can have incorrect syntax in their @context|@test - remedy is to do some static analysis beforehand, by parsing these expressions (using BaseX's xquery:parse()). CHECKME: can't the same also be true of *compiled* schemas?</para>
    </section>
    <section>
        <title>Compiled schema</title>
        <para>details of impl, any notable points</para>
    </section>
    <section>
        <title>Other features</title>
        <para>user-defined functions supported, via &lt;function xmlns='http://www.w3.org/2012/xquery'></para>
        <para>maps, function items in progress</para>
        <para>impl of pattern variables, cf. SchXslt[CITE issues + conformance suite failure]</para>
        <para>pattern/@documents?</para>
        <para>refer back to programmatic assembly of schemas and potential use of API for unit testing</para>
    </section>
    <section>
        <title>Testing</title>
        <para>BaseX unit module. Compile tests essentially come for free \o/</para>
    </section>
    <section>
        <title>Status of the work</title>
        <para>early release - bug reports welcome - not production ready</para>
        <section>
            <title>Conformance</title>
            <para>refer back to minimal/full definitions above for assessment</para>
            <para>David's conformance suite</para>
        </section>
        <section>
            <title>Future work/roadmap</title>
            <para>what's on the cards: see github enhancement issues</para>
            <para>mention tidying up the compile module with some templating for functions generated?</para>
        </section>
        <section>
            <title>A note on performance</title>
            <para>the BP DocBook example?</para>
            <para>underline that no attempt to optimize either approach (evaluation or compilation) has been attempted</para>
            <para>there's obvious scope for this, perhaps e.g. caching result of evaluating commonly-occurring rule/@context? - but more rigorous benchmarking needed to direct efforts most effectively</para>
        </section>
    </section>
    <section>
        <title>Lessons learnt</title>
        <para>doing the compilation part first would have made life a bit easier</para>
        <para></para>
    </section>
    <bibliography>
        <bibliomixed xml:id="schematron-existdb"><link xlink:href="https://github.com/Schematron/schematron-exist">https://github.com/Schematron/schematron-exist</link></bibliomixed>
        <bibliomixed xml:id="schematron-basex"><link xlink:href="https://github.com/Schematron/schematron-basex">https://github.com/Schematron/schematron-basex</link></bibliomixed>
        <bibliomixed xml:id="schematron-ML"><link xlink:href="https://github.com/ndw/ML-Schematron">https://github.com/ndw/ML-Schematron</link></bibliomixed>
        <bibliomixed xml:id="probatron"><link xlink:href="https://code.google.com/archive/p/probatron/">Probatron</link></bibliomixed>
        <bibliomixed xml:id="ph-schematron"><link xlink:href="https://phax.github.io/ph-schematron/">ph-schematron</link></bibliomixed>
        <bibliomixed xml:id="skeleton"><link xlink:href="https://github.com/Schematron/schematron">Skeleton implementation</link>, archived October 2020.</bibliomixed>
        <bibliomixed xml:id="schxslt"><link xlink:href="https://github.com/schxslt/schxslt">SchXslt</link></bibliomixed>
        <bibliomixed xml:id="iso-qlbs">ISO/IEC 19757-3:2020, Clause 6.4; Annexes H-M. <link xlink:href="https://www.iso.org/standard/74515.html"></link>.</bibliomixed>
        <bibliomixed xml:id="meetups">Schematron Users Meetup, at <confgroup><conftitle>XML Prague</conftitle><confdates>2017-20, 2022</confdates></confgroup>, <link xlink:href="https://www.xmlprague.cz/">https://www.xmlprague.cz/</link></bibliomixed>
    </bibliography>
</article>
